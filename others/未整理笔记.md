# 未整理笔记

## js

- 一个文件，一个模块
- 函数不依赖this（便于拆分、组合使用）
- 内部数据、函数，全部暴露出来（便于测试）
- 将配置好的服务实例作为模块暴露

## 代码规范

- 公共方法必须校验参数
- 不能在循环中调用服务，例如远程服务调用、读写数据库等

## next.js

### v3

- 不要使用clean url，这样每个url都唯一对应一个文件，也不需要custom server，而且在做静态输出的时候也更方便
- 若不使用ssr特性，则可以使用next进行静态输出
- code spliting and lazy loading
  - 非通用工具使用lazy loading（需要整理一份通用工具约定表？）
  - 散装的组件间均使用dynamic import
  - 封装的组件，该组件对内部组件及组件间均使用static import
- 业务逻辑全部靠页面来组织，组件全部为功能性组件
- 避免使用server only module。ssr中，主体仍是client，server仅负责页面首次渲染这个“轻量级”工作，其行为和依赖的包应该尽量和客户端保持一致。参考[这篇文章](https://arunoda.me/blog/ssr-and-server-only-modules)。
- 页面需要的数据可分为**前置数据**和**后置数据**
  - 前置数据通过`getInitialProps`来获取，只能使用url参数
  - 后置数据通过`componentDidMount`等lifecycle methods来获取
  - `getInitialProps`对于第一页在服务端调用，对于后续页在客户端调用；`componentDidMount`只在客户端调用
- 多入口问题
  - 传统spa中比较容易找到统一的应用入口，而next.js中每个page均是一个应用入口
  - 页面需要的应用功能和设施，通过HOC的方式提供，页面按需选用，避免过度加载
  - 这一类型的HOC，内部按单例模式来初始化相关应用设施，以避免重复初始化问题
